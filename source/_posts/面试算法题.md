---
title: 面试算法题 --- 畅融金服
date: 2019-02-25 22:13:25
categories: 算法
tags:
- java
---

### 前言

不知道为什么要写这个前言，总觉得这次的面试和以往不一样，所以就写一下心理历程吧。往常遇到的面试都是面试技术点的，比如java基础、Spring相关的框架、数据库相关的、JVM相关的等等，这次的面试，这些都不问，就一道算法题，做出来就面谈，做不出来就走人，直截了当。（后面来了好几个人，做了一会就走了，真TM吓人.........可能和我的性格有关吧，我就要死磕，给它做出来.............我大老远跑过来，午饭都没吃，不做出来，有点不甘心..............QAQ）

### 问题描述

写一个方法，输入一个奇数，输出如下格式：

输入1：

```java
// 输出：
1
```

输入3：

```java
// 输出
4 3 1
  1 3 4  
```

输入5：

```java
// 输出
12 8 5 1
   4 3 3 4
     1 5 8 12
```

输入7：

```java
// 输出
32 20 12 7  1
   12 8  5  3  4
      4  3  5  8  12
         1  7  12 20 32
```

**要求：输出是一个平行四边形，且是中心对称的，并且上下要竖直不能错开（输出不可以用 \t 来格式化，要求计算空格）。**
<!--more-->
### 思路

1. 既然是中心对称的，那我们先从中间分开，看左边一半或是右边一半，这里我们先看右边一半吧，好理解一些，如下：

   ```java
   1
   3 4
   5 8  12
   7 12 20 32
   ```

2. 然后就是找规律：

   - 竖着看第一列，发现行数等于第一列的数字加一，然后除以2

   - 每行的后面的数字等于前面的数字加上该数字上面的数字，如32=20+12

   - 如果输入的n=7，那么最后一行是7，12，20，32，那么这四个数字的可以用下面的方法算出来：

     ```java
     // 输入n=7,最后一行的数字：
     (2^0)*(n-0)   (2^1)*(n-1)   (2^2)*(n-2)   (2^3)*(n-3)
     ```

3. 至此，右边这一半已经解决了，就是算法怎么写的问题；右边的算法写出来之后，你会发现，把算法反过来写，就是左边的输出。

4. 然后将两个输出组合在一起输出就能得到下面的结果，不是平行四边形

   ```java
   32 20 12 7  1
   12 8  5  3  4
   4  3  5  8  12
   1  7  12 20 32
   ```

5. 最后，就是上面要求提到的，需要计算空格了，最终结果如下：

   ```java
   // 输入7
   --------------------------------
   // 输出
   32 20 12 7  1
      12 8  5  3  4
         4  3  5  8  12
            1  7  12 20 32
   ```

### 代码

```java
/**
 * Created by dazhan on 2019/2/25 22:27.
 */
public class Test {

    public static void main(String[] args) {
        int n = 21;
        // 输入奇数n, n>0
        SysOut(n);
    }

    private static void SysOut(int n) {
        String ss = String.valueOf((int)(Math.pow(2, ((n+1)/2 -1))*(n-((n+1)/2)+1)));
        int space = ss.length() + 1;
        for (int i = 1; i <= (n+1)/2; i++) {
            // 输出平行四边形
            String sp = "";
            for (int m = 1; m < i; m++) {
                while (sp.length() < space) {
                    sp = sp + " ";
                }
                System.out.print(sp);
            }

            // 左边一半
            for (int j = (n+1)/2 -i; j >= 0; j--) {
                String value = String.valueOf((int)(Math.pow(2, j)*(n-(2*i) -j +2)));
                // 计算空格
                while (value.length() < space) {
                    value = value + " ";
                }
                System.out.print(value);
            }

            // 右边一半
            for (int j = 0; j < i; j++) {
                String value = String.valueOf((int)(Math.pow(2, j)*(2*i -1 -j)));
                // 计算空格
                while (value.length() < space) {
                    value = value + " ";
                }
                System.out.print(value);
            }
            System.out.println();
        }
    }
}
---------------------------------------------------------------------------------------
执行结果如下：
192 112 64  36  20  11  1   
    80  48  28  16  9   3   4   
        32  20  12  7   5   8   12  
            12  8   5   7   12  20  32  
                4   3   9   16  28  48  80  
                    1   11  20  36  64  112 192
```

### 总结

遇到算法题的时候，千万不要放弃，把思路一点一点写下来，这样问题就解决了一半，这道题，我觉得难点就是把正序输出和反序输出组合起来的时候，有点费脑子........当然了，我这个解法是最常规的方法，肯定有比这个简单的方法的。。。只是当时时间有限，只能这样做了！QAQ







